# Content Table



# Github Repository
https://github.com/swyannnn/CW2024

# Introduction
Welcome to my Developing Maintenance Software coursework project. I am Seow Weng Yann (Student ID: 20618809), and this project focuses on creating a professional implementation of the classic game **1942**.

## Project Goals

- **User-Friendly Design:** Develop an intuitive and hassle-free gaming experience that is easy to understand and enjoyable to play.
- **Enhanced User Experience:** Focus on improving the overall user interaction and engagement with the game.
- **Maintainable Codebase:** Refactor the existing code to ensure it is clean, well-organized, and prepared for future expansions and enhancements.

## Usage

For the best experience, it is recommended to view this `README.md` file on the [GitHub website](https://github.com/swyannnn/CW2024). Navigation links have been embedded throughout the document to facilitate easy access to different sections.

---

# Compilation Instructions

# Implemented and Working Properly

This section details the features that have been successfully implemented in both the frontend and backend of the project. Each feature is explained by outlining the original version, the shortcomings of that approach, the new implementation, and the reasons why the modifications enhance the overall project.

## Frontend

1. **Keyboard Shortcuts for Button Presses**
   
   - **Original Version:**  
     The original game had no clickable buttons, relying solely on predefined controls without any keyboard shortcuts.
     
   - **Reason for Improvement:**  
     Without keyboard shortcuts, navigation and interaction were limited, potentially hindering user accessibility and ease of use.
     
   - **New Implementation:**  
     The game now supports convenient keyboard shortcuts, allowing players to easily navigate and activate menu options without needing to click with the mouse.
     
   - **Reason for Modification:**  
     Enhancing accessibility and improving user experience by enabling quick and efficient navigation through the game interface.

2. **Main Menu**
   
   - **Original Version:**  
     The original game lacked a main menu, providing no centralized hub for accessing different game functionalities.
     
   - **Reason for Improvement:**  
     Without a main menu, players had limited options to start the game, adjust settings, or navigate to different sections, leading to a disorganized entry point.
     
   - **New Implementation:**  
     A comprehensive main menu has been developed, offering players options to start the game, adjust settings, and select other functionalities.
     
   - **Reason for Modification:**  
     Providing a centralized hub for game navigation enhances user experience and allows for easy access to various game functionalities.

3. **Number of Players Option**
   
   - **Original Version:**  
     The original game only allowed for single-player mode.
     
   - **Reason for Improvement:**  
     Limiting the game to single player mode restricted the potential audience and replayability.
     
   - **New Implementation:**  
     Players can now choose between single player or double player modes before starting the game, allowing for a tailored experience based on player preferences.
     
   - **Reason for Modification:**  
     Catering to different player preferences increases the game's appeal and accommodates both solo and group gaming sessions.

4. **Level Instructions**
   
   - **Original Version:**  
     The original game did not provide any instructions, leaving players unaware of game objectives and controls.
     
   - **Reason for Improvement:**  
     Lack of instructions can lead to player confusion, frustration, and a diminished gaming experience.
     
   - **New Implementation:**  
     Instructions are now available before each level, providing players with guidance on objectives and controls, ensuring they know what to expect when gameplay begins.
     
   - **Reason for Modification:**  
     Offering clear instructions helps players understand game mechanics and objectives, reducing confusion and enhancing overall gameplay experience.

5. **Pause Option**
   
   - **Original Version:**  
     The original game did not allow players to pause gameplay.
     
   - **Reason for Improvement:**  
     Inability to pause can disrupt the gaming experience, especially during unforeseen interruptions or the need for breaks.
     
   - **New Implementation:**  
     The game can now be paused at any time during play using a keyboard shortcut or by clicking on the settings icon, providing players with more control over their gaming experience and the flexibility to resume gameplay at their own pace.
     
   - **Reason for Modification:**  
     Allowing players to pause the game enhances user control and convenience, enabling them to take breaks without losing progress.

6. **Scrolling Backgrounds**
   
   - **Original Version:**  
     The original game featured a static background, lacking visual dynamism.
     
   - **Reason for Improvement:**  
     Static backgrounds can make the game feel monotonous and less immersive.
     
   - **New Implementation:**  
     A visually appealing scrolling background has been implemented to enhance the game's aesthetics and immersion, creating a dynamic and engaging atmosphere.
     
   - **Reason for Modification:**  
     Improving visual appeal and immersion keeps players engaged and provides a more enjoyable and lively gaming environment.

7. **Player(s) Horizontal Movement**
   
   - **Original Version:**  
     The original game only allowed player movement along the vertical axis.
     
   - **Reason for Improvement:**  
     Restricting movement to one axis limits gameplay complexity and player control.
     
   - **New Implementation:**  
     The player characters can now move smoothly and intuitively along the horizontal axis, allowing for responsive and fluid gameplay.
     
   - **Reason for Modification:**  
     Ensuring responsive controls enhances gameplay fluidity and player satisfaction by providing seamless interaction with the game environment.

8. **Automated Fire Projectile without Key Press**
   
   - **Original Version:**  
     Players needed to press the spacebar to fire projectiles, which could be cumbersome during intense gameplay.
     
   - **Reason for Improvement:**  
     Requiring repetitive key presses can lead to player fatigue and distract from strategic gameplay elements.
     
   - **New Implementation:**  
     The fire mechanism has been automated to ensure continuous firing without extra input, allowing players to focus more on movement, evasion, and strategy rather than repeatedly pressing a key.
     
   - **Reason for Modification:**  
     Reducing the need for repetitive key presses minimizes player fatigue and allows for a more engaging and strategic gameplay experience.

9. **Audio Integration**
   
   - **Original Version:**  
     The original game lacked audio and sound effects.
     
   - **Reason for Improvement:**  
     Absence of audio can make the game feel less immersive and fail to provide essential feedback to player actions.
     
   - **New Implementation:**  
     Audio elements, such as background music, sound effects, and in-game notifications, have been successfully integrated to enhance the overall user experience. This includes adding immersive sound effects for events like firing projectiles, explosions, and level completions.
     
   - **Reason for Modification:**  
     Incorporating audio enhances the game's atmosphere and immersion, making the gameplay more engaging and enjoyable for players.

10. **Visual Effects**
    
    - **Original Version:**  
      The original game had poor visual feedback with minimal effects.
      
    - **Reason for Improvement:**  
      Lack of visual effects can make the game feel unresponsive and less exciting.
      
    - **New Implementation:**  
      Visual effects, including explosions, player actions, and enemy interactions, have been implemented to provide an engaging and visually dynamic experience. These effects add to the atmosphere, making the gameplay more enjoyable and visually rewarding.
      
    - **Reason for Modification:**  
      Enhancing visual feedback and effects improves the game's aesthetic appeal and provides satisfying visual cues that enrich the player's experience.

11. **Creation of Playable Levels**
    
    - **Original Version:**  
      The original game only featured two playable levels.
      
    - **Reason for Improvement:**  
      Limited levels reduce the game's replayability and can lead to player boredom.
      
    - **New Implementation:**  
      Two additional playable levels have been created, each with increasing difficulty, distinct environments, and unique challenges. This ensures that the game provides a continuous sense of progression and achievement for players.
      
    - **Reason for Modification:**  
      Offering diverse and progressively challenging levels keeps players engaged and motivated to continue playing, fostering a sense of accomplishment. For more detailed information on the implementation of levels 3 and 4, please refer to [Level Implementation Details](#).

12. **Game Over Screen**
    
    - **Original Version:**  
      The original game displayed a game over icon upon losing but did not offer options to restart or return to the main menu.
      
    - **Reason for Improvement:**  
      Without options to retry or navigate away, players have limited control after failing, which can lead to frustration.
      
    - **New Implementation:**  
      A Game Over screen has been developed to inform players when they have lost all their lives or failed a level. This screen provides options to retry the level, return to the main menu, or exit the game, ensuring a clear and user-friendly end to a gaming session.
      
    - **Reason for Modification:**  
      Providing actionable options helps players understand their progress and decide on their next steps, enhancing the overall user experience.

13. **Win Screen**
    
    - **Original Version:**  
      The original game displayed a win icon upon completion but did not offer options to proceed further or return to the main menu.
      
    - **Reason for Improvement:**  
      Without options to continue, players may feel the game ends abruptly without clear next steps.
      
    - **New Implementation:**  
      Upon successfully completing the game or a level, a Win Screen is displayed to congratulate players on their achievement. This screen includes options to replay the game or return to the main menu, enhancing the sense of accomplishment and providing clear next steps.
      
    - **Reason for Modification:**  
      Celebrating player achievements reinforces positive gameplay experiences and motivates continued engagement with the game.

## Backend

1. **State Management**
   
   - **Original Version:**  
     The original game did not implement state management, leading to potential issues with handling different game states and transitions.
     
   - **Reason for Improvement:**  
     Without proper state management, the game may experience bugs, inconsistent behavior, and difficulties in maintaining a coherent flow between different game states.
     
   - **New Implementation:**  
     Effective state management has been implemented to handle various game states such as the main menu, gameplay, pause, game over, and win screens. This ensures smooth transitions between different states and maintains the integrity of the game's flow, providing a seamless user experience.
     
   - **Reason for Modification:**  
     Proper state management is crucial for maintaining game stability and ensuring that transitions between different parts of the game are handled efficiently and without issues.

2. **Clean Up When Quitting Game**
   
   - **Original Version:**  
     The original game did not implement clean-up procedures, potentially leading to resource leaks and data integrity issues upon exiting.
     
   - **Reason for Improvement:**  
     Without proper clean-up, the game may leave behind unused resources, consume unnecessary memory, and risk data corruption, leading to performance degradation and reliability issues.
     
   - **New Implementation:**  
     Proper clean-up procedures are now in place to ensure that all resources are released and any necessary data is saved when the player quits the game. This prevents memory leaks, ensures data integrity, and guarantees that the game can be restarted without issues.
     
   - **Reason for Modification:**  
     Ensuring proper resource management and data integrity is essential for maintaining game performance and providing a reliable experience for players when they exit the game.

3. **Level Factory**
   
   - **Original Version:**  
     The original game did not utilize a level factory, limiting flexibility in level management and creation.
     
   - **Reason for Improvement:**  
     Without a level factory, adding or modifying levels can become cumbersome and error-prone, hindering scalability and maintainability.
     
   - **New Implementation:**  
     A level factory has been created to dynamically load levels (e.g., Level001, Level002, etc.). If a subsequent level is not found, the game will automatically transition to the win state.
     
   - **Reason for Modification:**  
     Implementing a level factory enhances the scalability and flexibility of the game, making it easier to add new levels and manage existing ones efficiently. It also ensures that the game can handle the end of available levels gracefully by transitioning to the win state.

4. **Implementation of Listeners**
   
   - **Original Version:**  
     The original game lacked listeners for key events such as health changes and collisions, limiting the ability to respond dynamically to in-game events.
     
   - **Reason for Improvement:**  
     Without listeners, the game cannot effectively respond to dynamic events, leading to a less interactive and reactive gaming experience.
     
   - **New Implementation:**  
     Listeners have been implemented, including health change listeners, `PropertyChangeSupport`, and collision listeners. These enable the game to respond appropriately to various in-game events, such as player health updates and collision detections.
     
   - **Reason for Modification:**  
     Implementing listeners allows the game to handle dynamic events more effectively, improving interactivity and responsiveness, which enhances the overall gameplay experience.

5. **Constants Management**
   
   - **Original Version:**  
     The original game scattered constant values throughout the codebase, making it difficult to manage and maintain.
     
   - **Reason for Improvement:**  
     Disorganized constant management can lead to inconsistencies, increased potential for errors, and challenges in updating values across the codebase.
     
   - **New Implementation:**  
     A dedicated class has been created to store all constant values, centralizing the management of fixed parameters used throughout the game.
     
   - **Reason for Modification:**  
     Centralizing constant values improves code maintainability and readability, making it easier to update and manage fixed parameters consistently across the entire codebase.

---

Feel free to attach **GIFs**, **images**, or **links** that showcase each feature for visual clarity and demonstration!


# Implemented but Not Working Properly

1. 

# Features Not Implemented

1. **Memento Pattern**

2. **Smooth Screen Transition**

# New Java Classes
`/com/example/demo/manager`

---
1. `GameStateManager` [[link](./src/main/java/com/example/demo/manager/GameStateManager.java)]

**Design Pattern Used**: Singleton

| **Feature**               | **Description**                                                                                                                                          |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| **State Management**      | Implements the **State Design Pattern** to switch between various game states (e.g., Main Menu, Level, Win, Lose).                                         |
| **Game Loop Control**     | Utilizes `AnimationTimer` to create a continuous game loop that updates and renders the current state.                                                     |
| **Input Handling**        | Delegates input events to the active game state for context-specific processing.                                                                          |
| **Resource Coordination** | Interacts with other managers (`AudioManager`, `ImageManager`, `ActorManager`, `CollisionManager`) to manage game resources effectively.                  |
| **Pause Functionality**   | Provides mechanisms to pause and resume the game, affecting the game loop.                                                            |
---
2. `AudioManager` [[link](./src/main/java/com/example/demo/manager/AudioManager.java)]

**Design Pattern Used**: Singleton

### **Key Responsibilities**

| **Feature**            | **Description**                                                                                                                                          |
|------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Audio Playback**     | Manages the playing, pausing, and stopping of background music and sound effects.                                                                         |
| **Resource Management**| Preloads audio files to minimize latency during gameplay, reducing delays when playing sounds.                                                               |
| **Volume Control**     | Provides mechanisms to enable or disable audio and adjust volume levels as needed.                                                                          |

---
3. `ButtonManager` [[link](./src/main/java/com/example/demo/manager/ButtonManager.java)]

---
4. `CollisionManager` [[link](./src/main/java/com/example/demo/manager/CollisionManager.java)]

**Design Patterns Used**: Singleton

| **Feature**               | **Description**                                                                                                                                                       |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Collision Detection**   | Implements algorithms to detect collisions between different types of actors, such as projectiles hitting enemies or players colliding with enemies.                   |
| **Collision Response**    | Defines and executes the appropriate responses when collisions are detected, such as reducing health, triggering explosion effects, or removing actors from the game.  |
| **Optimization**          | Utilizes bounding box shrinking to fine-tune collision detection accuracy and reduce false positives.                                                                 |
| **Event Notification**    | Communicates collision events to listeners (e.g., `CollisionListener`) to trigger player health updating actions.    
---
- `ActorManager` [[link](./src/main/java/com/example/demo/manager/ActorManager.java)]

**Design Patterns Used**: Singleton

**Key Responsibilities:**

| **Feature**                 | **Description**                                                                                                                                                       |
|-----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Actor Lifecycle Management** | Manages the addition, updating, and removal of actors in the game.                                                                                                     |
| **Rendering Coordination**  | Ensures that actors are correctly added to and removed from the scene graph (`Group`), facilitating their visual representation.                                        |
| **UI Element Management**   | Handles the addition and removal of UI elements separate from active actors.                                                                                           |
| **Actor Categorization**    | Provides methods to retrieve specific categories of actors (e.g., players, projectiles, enemies) for targeted operations.                                               |
---
4. `ImageManager` [[link](./src/main/java/com/example/demo/manager/ImageManager.java)]

**Design Patterns Used**: Singleton

**Key Responsibilities:**

- Image Loading: Loads image assets from specified file paths as needed for different game components.

- Caching Mechanism: Implements a caching strategy to store and retrieve images efficiently, preventing redundant loading and reducing memory consumption.

- Image Sequence Handling: Provides functionality to load sequences of images (e.g., animation frames) based on naming patterns.

- Preloading: Preloads all necessary images during initialization to ensure immediate availability during gameplay, reducing runtime delays.

- Resource Management: Allows for clearing the image cache when necessary, freeing up memory resources.
---
`/com/example/demo/actor/plane`

7. **EnemyPlane1**

8. **EnemyPlane2**

9. **EnemyPlane3**

10. **EnemyPlane4**

11. **MultiPhaseBossPlane**

`/com/example/demo/effect`

12. **ExplosionEffect**

`/com/example/demo/level`

13. **Level003**

14. **Level004**

15. **LevelFactory**

16. **LevelParent**

`/com/example/demo/listener`

17. **CollisionListener**

18. **HealthChangeListener**

`/com/example/demo/state`

19. **GameState**

20. **GameStateFactory**

21. **LevelState**

22. **LoseState**

23. **MainMenuState**

24. **WinState**

`/com/example/demo/ui`

25. **LoseScreen**

26. **MainMenu**

27. **PauseOverlay**

28. **WinScreen**

`/com/example/demo/util`

29. **GameConstant**

# Modified Java Classes
`/com/example/demo/actor`

1. **ActiveActor**

2. **ActiveActorDestructible**

3. **Destructible**

`/com/example/demo/plane`

5. **BossPlane**

6. **EnemyPLane**

7. **FighterPlane**

8. **UserPlane**

`/com/example/demo/projectile`

9. **Projectile**

10. **UserProjectile**

`/com/example/demo/level`

11. **Level001** (previously known as **LevelOne**)

12.  **Level002** (previously known as **LevelTwo**)

13. **LevelParent**

`/com/example/demo/ui`

14. **HeartDisplay**

15. **LevelView** (previously know as **LevelViewLevelOne**)

16. **Shield** (previously know as **ShieldImage**)

# Unexpected Problems

1. Tight Coupling between classes

ActorManager and GameStateManager

2. Continous Errors

Time consuming and frustration

# Additional section 

This section is intended for more clarifications about my work, easing the marking for module convener(s). I will go through each bullet points stated in MARKING CRITERIA/RUBRIC.

**Git**

1. Project exists

Of course! Please kindly check out this attached link

